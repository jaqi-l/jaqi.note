<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>3.15.1 什么是面向对象编程 | jaqi.note</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/jaqi.note/logo.jpg">
    <script>
                var _hmt = _hmt || [];
                (function() {
                    var hm = document.createElement("script");
                    hm.src = "https://hm.baidu.com/hm.js?b7303024b1d1000570507a8af21071bd";
                    var s = document.getElementsByTagName("script")[0];
                    s.parentNode.insertBefore(hm, s);
                })();
           </script>
    <meta name="description" content="字典，是惟一把成功放在工作之前的地方！">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <link rel="preload" href="/jaqi.note/assets/css/0.styles.12fde6e5.css" as="style"><link rel="preload" href="/jaqi.note/assets/js/app.a8f46c6d.js" as="script"><link rel="preload" href="/jaqi.note/assets/js/2.244728d6.js" as="script"><link rel="preload" href="/jaqi.note/assets/js/46.47b4f55a.js" as="script"><link rel="prefetch" href="/jaqi.note/assets/js/10.a3d0cc58.js"><link rel="prefetch" href="/jaqi.note/assets/js/11.e51336c9.js"><link rel="prefetch" href="/jaqi.note/assets/js/12.2b2d4813.js"><link rel="prefetch" href="/jaqi.note/assets/js/13.221369e0.js"><link rel="prefetch" href="/jaqi.note/assets/js/14.eb9cf3af.js"><link rel="prefetch" href="/jaqi.note/assets/js/15.ad6b7f26.js"><link rel="prefetch" href="/jaqi.note/assets/js/16.ad1a8e83.js"><link rel="prefetch" href="/jaqi.note/assets/js/17.f8467963.js"><link rel="prefetch" href="/jaqi.note/assets/js/18.91cbda41.js"><link rel="prefetch" href="/jaqi.note/assets/js/19.1608df84.js"><link rel="prefetch" href="/jaqi.note/assets/js/20.1190128a.js"><link rel="prefetch" href="/jaqi.note/assets/js/21.2945f88f.js"><link rel="prefetch" href="/jaqi.note/assets/js/22.056953db.js"><link rel="prefetch" href="/jaqi.note/assets/js/23.b5d59bc1.js"><link rel="prefetch" href="/jaqi.note/assets/js/24.2c21d3a7.js"><link rel="prefetch" href="/jaqi.note/assets/js/25.6312812f.js"><link rel="prefetch" href="/jaqi.note/assets/js/26.82ec113c.js"><link rel="prefetch" href="/jaqi.note/assets/js/27.560f09bf.js"><link rel="prefetch" href="/jaqi.note/assets/js/28.67b96731.js"><link rel="prefetch" href="/jaqi.note/assets/js/29.7c8cbfa8.js"><link rel="prefetch" href="/jaqi.note/assets/js/3.ac7fa2ce.js"><link rel="prefetch" href="/jaqi.note/assets/js/30.2698e05b.js"><link rel="prefetch" href="/jaqi.note/assets/js/31.93b84d6e.js"><link rel="prefetch" href="/jaqi.note/assets/js/32.d9d0f81a.js"><link rel="prefetch" href="/jaqi.note/assets/js/33.dedb4302.js"><link rel="prefetch" href="/jaqi.note/assets/js/34.ffeea0c2.js"><link rel="prefetch" href="/jaqi.note/assets/js/35.d7cb5d3a.js"><link rel="prefetch" href="/jaqi.note/assets/js/36.602c739a.js"><link rel="prefetch" href="/jaqi.note/assets/js/37.ef428da6.js"><link rel="prefetch" href="/jaqi.note/assets/js/38.5dd8d150.js"><link rel="prefetch" href="/jaqi.note/assets/js/39.a0b7df6a.js"><link rel="prefetch" href="/jaqi.note/assets/js/4.4e656f32.js"><link rel="prefetch" href="/jaqi.note/assets/js/40.54d5162d.js"><link rel="prefetch" href="/jaqi.note/assets/js/41.20face75.js"><link rel="prefetch" href="/jaqi.note/assets/js/42.ca746304.js"><link rel="prefetch" href="/jaqi.note/assets/js/43.8a9dcb5b.js"><link rel="prefetch" href="/jaqi.note/assets/js/44.45ab42be.js"><link rel="prefetch" href="/jaqi.note/assets/js/45.76555fad.js"><link rel="prefetch" href="/jaqi.note/assets/js/47.8a44f3b0.js"><link rel="prefetch" href="/jaqi.note/assets/js/48.369b86bb.js"><link rel="prefetch" href="/jaqi.note/assets/js/49.9ae0f9ed.js"><link rel="prefetch" href="/jaqi.note/assets/js/5.ebe65fd8.js"><link rel="prefetch" href="/jaqi.note/assets/js/50.3add5b2a.js"><link rel="prefetch" href="/jaqi.note/assets/js/51.365fca19.js"><link rel="prefetch" href="/jaqi.note/assets/js/52.2f29e190.js"><link rel="prefetch" href="/jaqi.note/assets/js/53.7f2804c5.js"><link rel="prefetch" href="/jaqi.note/assets/js/54.c433774d.js"><link rel="prefetch" href="/jaqi.note/assets/js/55.8c703d74.js"><link rel="prefetch" href="/jaqi.note/assets/js/56.3dd8c5d1.js"><link rel="prefetch" href="/jaqi.note/assets/js/57.812c09be.js"><link rel="prefetch" href="/jaqi.note/assets/js/58.a6f4c6fb.js"><link rel="prefetch" href="/jaqi.note/assets/js/59.308369cc.js"><link rel="prefetch" href="/jaqi.note/assets/js/6.8e5bcc75.js"><link rel="prefetch" href="/jaqi.note/assets/js/60.cba25b4e.js"><link rel="prefetch" href="/jaqi.note/assets/js/61.538da168.js"><link rel="prefetch" href="/jaqi.note/assets/js/62.044d5759.js"><link rel="prefetch" href="/jaqi.note/assets/js/63.a9b077ef.js"><link rel="prefetch" href="/jaqi.note/assets/js/64.6a1adc86.js"><link rel="prefetch" href="/jaqi.note/assets/js/65.05e3fc84.js"><link rel="prefetch" href="/jaqi.note/assets/js/66.0fed1dee.js"><link rel="prefetch" href="/jaqi.note/assets/js/67.f07b5683.js"><link rel="prefetch" href="/jaqi.note/assets/js/68.3068e0a2.js"><link rel="prefetch" href="/jaqi.note/assets/js/69.c2b3f26d.js"><link rel="prefetch" href="/jaqi.note/assets/js/7.0da0bd62.js"><link rel="prefetch" href="/jaqi.note/assets/js/70.e1c4853e.js"><link rel="prefetch" href="/jaqi.note/assets/js/71.b28da8fc.js"><link rel="prefetch" href="/jaqi.note/assets/js/72.426f621e.js"><link rel="prefetch" href="/jaqi.note/assets/js/73.edcf4ba9.js"><link rel="prefetch" href="/jaqi.note/assets/js/74.e111b23a.js"><link rel="prefetch" href="/jaqi.note/assets/js/75.8630e7ea.js"><link rel="prefetch" href="/jaqi.note/assets/js/76.ecd68f89.js"><link rel="prefetch" href="/jaqi.note/assets/js/77.e715e962.js"><link rel="prefetch" href="/jaqi.note/assets/js/78.2cc330dd.js"><link rel="prefetch" href="/jaqi.note/assets/js/79.73b537aa.js"><link rel="prefetch" href="/jaqi.note/assets/js/8.7a309ab5.js"><link rel="prefetch" href="/jaqi.note/assets/js/80.a33858aa.js"><link rel="prefetch" href="/jaqi.note/assets/js/81.85f697a5.js"><link rel="prefetch" href="/jaqi.note/assets/js/82.48491c51.js"><link rel="prefetch" href="/jaqi.note/assets/js/83.0e2ac4fb.js"><link rel="prefetch" href="/jaqi.note/assets/js/9.772ca248.js">
    <link rel="stylesheet" href="/jaqi.note/assets/css/0.styles.12fde6e5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jaqi.note/" class="home-link router-link-active"><!----> <span class="site-name">jaqi.note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/jaqi.note/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发文档" class="dropdown-title"><span class="title">开发文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发文档" class="mobile-dropdown-title"><span class="title">开发文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jaqi.note/frontend/" class="nav-link router-link-active">
  前端
</a></li><li class="dropdown-item"><!----> <a href="/jaqi.note/other/" class="nav-link">
  其他
</a></li></ul></div></div><div class="nav-item"><a href="https://jaqi.gitee.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  jaqi.page
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://blog.csdn.net/ljq547152849" target="_blank" rel="noopener noreferrer" class="nav-link external">
  jaqi.csnd
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/jaqi.note/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发文档" class="dropdown-title"><span class="title">开发文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发文档" class="mobile-dropdown-title"><span class="title">开发文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jaqi.note/frontend/" class="nav-link router-link-active">
  前端
</a></li><li class="dropdown-item"><!----> <a href="/jaqi.note/other/" class="nav-link">
  其他
</a></li></ul></div></div><div class="nav-item"><a href="https://jaqi.gitee.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  jaqi.page
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://blog.csdn.net/ljq547152849" target="_blank" rel="noopener noreferrer" class="nav-link external">
  jaqi.csnd
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/jaqi.note/frontend/" class="sidebar-heading clickable router-link-active open"><span>前端</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/jaqi.note/frontend/html/introduction/" class="sidebar-heading clickable"><span>第一章：HTML5</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/jaqi.note/frontend/css/introduction/" class="sidebar-heading clickable"><span>第二章：CSS</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/jaqi.note/frontend/javascript/var/" class="sidebar-heading clickable open"><span>第三章：JavaScript</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/jaqi.note/frontend/javascript/var/" class="sidebar-link">3.1 变量</a></li><li><a href="/jaqi.note/frontend/javascript/datatype/" class="sidebar-link">3.2 数据类型</a></li><li><a href="/jaqi.note/frontend/javascript/symbol/" class="sidebar-link">3.3 运算符</a></li><li><a href="/jaqi.note/frontend/javascript/control/" class="sidebar-link">3.4 控制语句</a></li><li><a href="/jaqi.note/frontend/javascript/function/" class="sidebar-link">3.5 函数</a></li><li><a href="/jaqi.note/frontend/javascript/object/" class="sidebar-link">3.6 对象</a></li><li><a href="/jaqi.note/frontend/javascript/date/" class="sidebar-link">3.7 日期和时间对象</a></li><li><a href="/jaqi.note/frontend/javascript/math/" class="sidebar-link">3.8 Math对象</a></li><li><a href="/jaqi.note/frontend/javascript/string/" class="sidebar-link">3.9 字符串对象</a></li><li><a href="/jaqi.note/frontend/javascript/BOM/" class="sidebar-link">3.10 BOM</a></li><li><a href="/jaqi.note/frontend/javascript/DOM/" class="sidebar-link">3.11 DOM</a></li><li><a href="/jaqi.note/frontend/javascript/event/" class="sidebar-link">3.12 事件</a></li><li><a href="/jaqi.note/frontend/javascript/reg/" class="sidebar-link">3.13 正则</a></li><li><a href="/jaqi.note/frontend/javascript/sync&amp;asyn/" class="sidebar-link">3.14 同步与异步</a></li><li><a href="/jaqi.note/frontend/javascript/oop/" aria-current="page" class="active sidebar-link">3.15 面向对象编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_3-15-1-什么是面向对象编程" class="sidebar-link">3.15.1 什么是面向对象编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#面向过程-procedure-oriented简称po" class="sidebar-link">面向过程（Procedure Oriented简称PO）：</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#面向对象-object-oriented简称oo" class="sidebar-link">面向对象（Object Oriented简称OO）：</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#面向对象的相关概念" class="sidebar-link">面向对象的相关概念</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#面向对象编程的特性" class="sidebar-link">面向对象编程的特性</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#面向对象编程的五大基本原则" class="sidebar-link">面向对象编程的五大基本原则</a></li></ul></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_3-15-2-js面向对象编程概述" class="sidebar-link">3.15.2 JS面向对象编程概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#js内置类" class="sidebar-link">JS内置类</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#构造函数-类" class="sidebar-link">构造函数（类）</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#相关方法" class="sidebar-link">相关方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_3-15-3-对象封装方法" class="sidebar-link">3.15.3 对象封装方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_1、生成实例对象的原始模式" class="sidebar-link">1、生成实例对象的原始模式</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_2、原始模式的改进" class="sidebar-link">2、原始模式的改进</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_3、构造函数模式" class="sidebar-link">3、构造函数模式</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_4、构造函数模式的问题" class="sidebar-link">4、构造函数模式的问题</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_5、prototype模式" class="sidebar-link">5、Prototype模式</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_6、prototype模式的es6语法class" class="sidebar-link">6、Prototype模式的ES6语法class</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_7、prototype模式的验证方法" class="sidebar-link">7、Prototype模式的验证方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_3-15-4-构造函数继承方法" class="sidebar-link">3.15.4 构造函数继承方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_1、构造函数绑定" class="sidebar-link">1、构造函数绑定</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_2、prototype模式" class="sidebar-link">2、prototype模式</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_3、直接继承prototype" class="sidebar-link">3、直接继承prototype</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_4、利用空对象作为中介" class="sidebar-link">4、利用空对象作为中介</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_5、拷贝继承" class="sidebar-link">5、拷贝继承</a></li></ul></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_3-15-5-非构造函数的继承方法" class="sidebar-link">3.15.5 非构造函数的继承方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_1、object-方法" class="sidebar-link">1、object()方法</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_2、浅拷贝" class="sidebar-link">2、浅拷贝</a></li><li class="sidebar-sub-header"><a href="/jaqi.note/frontend/javascript/oop/#_3、深拷贝" class="sidebar-link">3、深拷贝</a></li></ul></li></ul></li><li><a href="/jaqi.note/frontend/javascript/ECMAScript/" class="sidebar-link">3.16 ECMAScript</a></li><li><a href="/jaqi.note/frontend/javascript/TypeScript/" class="sidebar-link">3.17 TypeScript</a></li></ul></section></li><li><a href="/jaqi.note/frontend/jquery/" class="sidebar-link">第四章：jQuery</a></li><li><a href="/jaqi.note/frontend/ajax/" class="sidebar-link">第五章：ajax</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/jaqi.note/frontend/vue/introduction/" class="sidebar-heading clickable"><span>第六章：vue.js</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/jaqi.note/frontend/webpack/" class="sidebar-link">第七章：webpack</a></li><li><a href="/jaqi.note/frontend/miniprogram/" class="sidebar-link">第八章：小程序</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_3-15-1-什么是面向对象编程"><a href="#_3-15-1-什么是面向对象编程" class="header-anchor">#</a> 3.15.1 什么是面向对象编程</h2> <h3 id="面向过程-procedure-oriented简称po"><a href="#面向过程-procedure-oriented简称po" class="header-anchor">#</a> 面向过程（Procedure Oriented简称PO）：</h3> <p>当解决一个问题的时候，面向过程会把事情拆分成：一个个函数和数据（用于方法的参数）。然后按照一定的顺序，执行完这些方法（每个方法看作一个过程），等方法执行完了，事情就搞定了。如<code>c</code></p> <ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。</li> <li>缺点：没有面向对象易维护、易复用、易扩展</li></ul> <h3 id="面向对象-object-oriented简称oo"><a href="#面向对象-object-oriented简称oo" class="header-anchor">#</a> 面向对象（Object Oriented简称OO）：</h3> <p>当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。<br>
如<code>js</code>/<code>java</code>/<code>php</code>/<code>c#</code>/<code>python</code>/<code>c++</code>/<code>ruby</code>/...</p> <ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。</li> <li>缺点：性能比面向过程低</li></ul> <h4 id="例子-五子棋"><a href="#例子-五子棋" class="header-anchor">#</a> 例子：五子棋</h4> <ul><li>面向过程的设计思路：</li></ul> <blockquote><p>1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。</p></blockquote> <ul><li>面向对象：</li></ul> <blockquote><p>整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。</p></blockquote> <p>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。</p> <h3 id="面向对象的相关概念"><a href="#面向对象的相关概念" class="header-anchor">#</a> 面向对象的相关概念</h3> <ul><li>对象：万物皆对象</li> <li>类：对象的具体细分（按功能特点进行分类 大类 小类）</li> <li>实例：类中一个具体的事物</li></ul> <h3 id="面向对象编程的特性"><a href="#面向对象编程的特性" class="header-anchor">#</a> 面向对象编程的特性</h3> <p>三大基本特性：封装，继承，多态</p> <ul><li>封装</li></ul> <p>封装，就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p> <ul><li>继承</li></ul> <p>继承，指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过 “继承”和“组合”来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用父类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。</p> <ul><li>多态</li></ul> <p>多态，是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p> <h3 id="面向对象编程的五大基本原则"><a href="#面向对象编程的五大基本原则" class="header-anchor">#</a> 面向对象编程的五大基本原则</h3> <ul><li>单一职责原则SRP(Single Responsibility Principle)</li></ul> <blockquote><p>是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。</p></blockquote> <ul><li>开放封闭原则OCP(Open－Close Principle)</li></ul> <blockquote><p>一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。</p></blockquote> <ul><li>里式替换原则LSP(the Liskov Substitution Principle LSP)</li></ul> <blockquote><p>子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。</p></blockquote> <ul><li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)</li></ul> <blockquote><p>具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一个抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。</p></blockquote> <ul><li>接口分离原则ISP(the Interface Segregation Principle ISP)</li></ul> <blockquote><p>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来</p></blockquote> <h2 id="_3-15-2-js面向对象编程概述"><a href="#_3-15-2-js面向对象编程概述" class="header-anchor">#</a> 3.15.2 JS面向对象编程概述</h2> <h3 id="js内置类"><a href="#js内置类" class="header-anchor">#</a> JS内置类</h3> <ul><li>JS内置类<code>Object</code>的基类分为以下小类：</li></ul> <blockquote><p><code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code>、<code>Function</code>、 <code>HTMLCollection</code>、<code>EventTarget</code>、<code>自定义类</code></p></blockquote> <ul><li>侠义对象、广义对象、严格对象：</li></ul> <blockquote><p>侠义对象：通过<code>{}</code>创建的对象
广义对象：<code>Array</code>、<code>Date</code>、<code>RegExp</code>、<code>Function</code>...
严格对象：<code>json</code></p></blockquote> <h3 id="构造函数-类"><a href="#构造函数-类" class="header-anchor">#</a> 构造函数（类）</h3> <h4 id="什么是构造函数"><a href="#什么是构造函数" class="header-anchor">#</a> 什么是构造函数：</h4> <blockquote><p>通过<code>new</code>关键字执行的，一般首字母大写的函数。构造函数的<code>this</code>指向函数本身。</p></blockquote> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>构造函数模没有<code>return</code>,默认会返回<code>this</code>对象,如果写<code>return</code>只能返回引用类型。</p></div> <h4 id="构造函数的创建过程"><a href="#构造函数的创建过程" class="header-anchor">#</a> 构造函数的创建过程：</h4> <blockquote><ol><li><code>new</code>关键字执行时，函数内部创建了一个空对象</li> <li><code>this</code>指向这个空对象</li> <li>执行函数内部的语句</li> <li>返回这个对象</li></ol></blockquote> <h4 id="构造函数的作用"><a href="#构造函数的作用" class="header-anchor">#</a> 构造函数的作用：</h4> <blockquote><p>创建对象时完成对对象属性的一些初始化等操作，为对象数据成员开辟内存空间，并给创建的对象建立一个统一标识符。</p></blockquote> <h4 id="原型对象prototype"><a href="#原型对象prototype" class="header-anchor">#</a> 原型对象<code>prototype</code></h4> <blockquote><p>每一个构造函数都有一个<code>prototype</code>对象，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p></blockquote> <h4 id="构造函数的constructor属性"><a href="#构造函数的constructor属性" class="header-anchor">#</a> 构造函数的<code>constructor</code>属性</h4> <blockquote><p>每一个构造函数都有一个<code>constructor</code>属性，指向它的构造函数。</p></blockquote> <h4 id="原型对象的constructor属性"><a href="#原型对象的constructor属性" class="header-anchor">#</a> 原型对象的<code>constructor</code>属性</h4> <blockquote><p>每一个原型对象（<code>prototype</code>）都有一个<code>constructor</code>属性，指向该原型对象对应的构造函数。</p></blockquote> <h4 id="构造函数的-proto-属性"><a href="#构造函数的-proto-属性" class="header-anchor">#</a> 构造函数的<code>__proto__</code>属性</h4> <blockquote><p>每个通过构造函数创建的对象都有一个<code>__proto__</code>属性，该属性指向原型对象</p></blockquote> <h4 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h4> <blockquote><p><img src="/jaqi.note/prototype.png" alt="prototype"></p></blockquote> <h4 id="原型链机制"><a href="#原型链机制" class="header-anchor">#</a> 原型链机制</h4> <blockquote><p>通过构造函数创建的对象会先查找自己的属性，如果没有通过<code>__proto__</code>去原型上查找。如果还没有就去自己原型对象的原型对象去查找，一直查找到<code>object</code>基类。</p></blockquote> <blockquote><p><code>Object.prototype</code>是所有对象的原型链的终点。</p></blockquote> <h4 id="系统内置构造函数"><a href="#系统内置构造函数" class="header-anchor">#</a> 系统内置构造函数：</h4> <ul><li><code>Object</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//obj是Object的实例</span>
obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'大毛'</span>
obj<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'黄色'</span>
</code></pre></div><ul><li><code>Function</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;console.log(a+b)&quot;</span><span class="token punctuation">)</span> <span class="token comment">//fn是Function的实例</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>color</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token operator">=</span>color<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&quot;猫科动物&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 通过原型设置公共属性</span>
<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;大毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黄色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;二毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黑色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 大毛</span>
<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 黄色</span>
<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 猫科动物</span>
</code></pre></div><h3 id="相关方法"><a href="#相关方法" class="header-anchor">#</a> 相关方法</h3> <p>详见：<a href="/jaqi.note/frontend/javascript/oop/#_7、prototype模式的验证方法">7、Prototype模式的验证方法</a></p> <h2 id="_3-15-3-对象封装方法"><a href="#_3-15-3-对象封装方法" class="header-anchor">#</a> 3.15.3 对象封装方法</h2> <p>封装的六种方法</p> <h3 id="_1、生成实例对象的原始模式"><a href="#_1、生成实例对象的原始模式" class="header-anchor">#</a> 1、生成实例对象的原始模式</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Cat <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token literal-property property">name</span> <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
   <span class="token literal-property property">color</span> <span class="token operator">:</span> <span class="token string">''</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个空对象</span>
　　cat1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;大毛&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 按照原型对象的属性赋值</span>
　　cat1<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&quot;黄色&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
　　cat2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;二毛&quot;</span><span class="token punctuation">;</span>
　　cat2<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&quot;黑色&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p> <h3 id="_2、原始模式的改进"><a href="#_2、原始模式的改进" class="header-anchor">#</a> 2、原始模式的改进</h3> <p>我们可以写一个函数，解决代码重复的问题。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
　　<span class="token keyword">return</span> <span class="token punctuation">{</span>
　　　　name<span class="token operator">:</span>name<span class="token punctuation">,</span>
　　　　color<span class="token operator">:</span>color
　　<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后生成实例对象，就等于是在调用函数：</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;大毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黄色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;二毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黑色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p> <h3 id="_3、构造函数模式"><a href="#_3、构造函数模式" class="header-anchor">#</a> 3、构造函数模式</h3> <p>为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（<code>Constructor</code>）模式。</p> <p>所谓&quot;构造函数&quot;，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>color</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　<span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
　　<span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token operator">=</span>color<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;大毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黄色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;二毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黑色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 大毛</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 黄色</span>
</code></pre></div><p>这时cat1和cat2会自动含有一个<code>constructor</code>属性，指向它们的构造函数。</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Cat<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat2<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Cat<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><p>使用<code>instanceof</code>运算符，验证原型对象与实例对象之间的关系。</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1 <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat2 <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><h3 id="_4、构造函数模式的问题"><a href="#_4、构造函数模式的问题" class="header-anchor">#</a> 4、构造函数模式的问题</h3> <p>构造函数方法很好用，但是存在一个浪费内存的问题。</p> <p>我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>color</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
　　<span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
　　<span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&quot;猫科动物&quot;</span><span class="token punctuation">;</span>
　　<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;吃老鼠&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>还是采用同样的方法，生成实例：</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;大毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黄色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span> <span class="token punctuation">(</span><span class="token string">&quot;二毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黑色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 猫科动物</span>
　　cat1<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 吃老鼠</span>
</code></pre></div><p>type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>eat <span class="token operator">==</span> cat2<span class="token punctuation">.</span>eat<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
</code></pre></div><h3 id="_5、prototype模式"><a href="#_5、prototype模式" class="header-anchor">#</a> 5、<code>Prototype</code>模式</h3> <p>Javascript规定，每一个构造函数都有一个<code>prototype</code>对象，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。
这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>color</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　　　<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
　　　　<span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
　　<span class="token punctuation">}</span>
	<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
		<span class="token literal-property property">type</span><span class="token operator">:</span><span class="token string">&quot;猫科动物&quot;</span>，
		<span class="token function-variable function">eat</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;吃老鼠&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p>然后，生成实例。</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;大毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黄色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;二毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黑色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 猫科动物</span>
　　cat1<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 吃老鼠</span>
</code></pre></div><p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>eat <span class="token operator">==</span> cat2<span class="token punctuation">.</span>eat<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><h3 id="_6、prototype模式的es6语法class"><a href="#_6、prototype模式的es6语法class" class="header-anchor">#</a> 6、<code>Prototype</code>模式的ES6语法<code>class</code></h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	type <span class="token operator">=</span> <span class="token string">&quot;猫科动物&quot;</span><span class="token punctuation">;</span>
	<span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;吃老鼠&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;大毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黄色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;二毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黑色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 猫科动物</span>
cat1<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 吃老鼠</span>
</code></pre></div><p><code>class</code>详见<a href="/jaqi.note/frontend/javascript/ECMAScript/#_3-16-19-class">3.16.19</a></p> <h3 id="_7、prototype模式的验证方法"><a href="#_7、prototype模式的验证方法" class="header-anchor">#</a> 7、<code>Prototype</code>模式的验证方法</h3> <p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，</p> <ol><li><code>isPrototypeOf()</code></li></ol> <p>这个方法用来判断，某个proptotype对象和某个实例之间的关系。</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>cat1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>cat2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><ol start="2"><li><code>hasOwnProperty()</code></li></ol> <p>每个实例对象都有一个<code>hasOwnProperty()</code>方法，用来判断某一个属性到底是本地属性，还是继承自<code>prototype</code>对象的属性。</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;type&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><ol start="3"><li><code>in</code>运算符</li></ol> <p><code>in</code>运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span> <span class="token keyword">in</span> cat1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;type&quot;</span> <span class="token keyword">in</span> cat1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p><code>in</code>运算符还可以用来遍历某个对象的所有属性。</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> prop <span class="token keyword">in</span> cat1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;cat1[&quot;</span><span class="token operator">+</span>prop<span class="token operator">+</span><span class="token string">&quot;]=&quot;</span><span class="token operator">+</span>cat1<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre></div><h2 id="_3-15-4-构造函数继承方法"><a href="#_3-15-4-构造函数继承方法" class="header-anchor">#</a> 3.15.4 构造函数继承方法</h2> <p>构造函数继承的五种方法</p> <div class="language-js extra-class"><pre class="language-js"><code>　<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　　<span class="token keyword">this</span><span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">&quot;动物&quot;</span><span class="token punctuation">;</span>
　<span class="token punctuation">}</span>
　<span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>color</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　　<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
　　　<span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
　<span class="token punctuation">}</span>
</code></pre></div><p>怎样才能使&quot;猫&quot;继承&quot;动物&quot;呢？</p> <h3 id="_1、构造函数绑定"><a href="#_1、构造函数绑定" class="header-anchor">#</a> 1、构造函数绑定</h3> <p>第一种方法也是最简单的方法，使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>color</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　<span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
　　<span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;大毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黄色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 动物</span>
</code></pre></div><h3 id="_2、prototype模式"><a href="#_2、prototype模式" class="header-anchor">#</a> 2、prototype模式</h3> <p>如果&quot;猫&quot;的prototype对象，指向一个Animal的实例，那么所有&quot;猫&quot;的实例，就能继承Animal了。</p> <div class="language-js extra-class"><pre class="language-js"><code>　　Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Cat的prototype对象指向一个Animal的实例。</span>
　　Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat<span class="token punctuation">;</span>
　　<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;大毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黄色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 动物</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>constructor <span class="token operator">==</span> <span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true 实例的constructor属性，默认同prototype对象constructor属性</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Animal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><code>Cat.prototype = new Animal();</code>它相当于完全删除了prototype对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？
<code>Cat.prototype.constructor = Cat;</code>任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有&quot;Cat.prototype = new Animal();&quot;这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。因此在替换prototype对象后需要将prototype的上constructor属性指回原来的构造函数。</p></div> <h3 id="_3、直接继承prototype"><a href="#_3、直接继承prototype" class="header-anchor">#</a> 3、直接继承prototype</h3> <p>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过Animal()，直接继承Animal.prototype</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>
　　Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">&quot;动物&quot;</span><span class="token punctuation">;</span>
　　Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 将Cat的prototype对象直接指向Animal的prototype对象，这样就完成了继承。</span>
　　Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat<span class="token punctuation">;</span>
　　<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;大毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黄色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 动物</span>
</code></pre></div><p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。
所以，上面这一段代码其实是有问题的。请看第二行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat<span class="token punctuation">;</span> <span class="token comment">// 这一句实际上把Animal.prototype对象的constructor属性也改掉了！</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cat</span>
</code></pre></div><h3 id="_4、利用空对象作为中介"><a href="#_4、利用空对象作为中介" class="header-anchor">#</a> 4、利用空对象作为中介</h3> <p>由于&quot;直接继承prototype&quot;存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token keyword">function</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token parameter">Child<span class="token punctuation">,</span> Parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
　　　　<span class="token keyword">var</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
　　　　<span class="token constant">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
　　　　Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　　　Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>
　　　　Child<span class="token punctuation">.</span>uber <span class="token operator">=</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
　　<span class="token punctuation">}</span>
<span class="token comment">//使用</span>
　　<span class="token function">extend</span><span class="token punctuation">(</span>Cat<span class="token punctuation">,</span>Animal<span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;大毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黄色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 动物</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <ol><li><code>F</code>是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。</li> <li><code>Child.uber = Parent.prototype;</code>意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性。</li></ol></div> <h3 id="_5、拷贝继承"><a href="#_5、拷贝继承" class="header-anchor">#</a> 5、拷贝继承</h3> <p>上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用&quot;拷贝&quot;方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p> <p>首先，还是把Animal的所有不变属性，都放到它的prototype对象上。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">&quot;动物&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 属性拷贝</span>
<span class="token keyword">function</span> <span class="token function">extend2</span><span class="token punctuation">(</span><span class="token parameter">Child<span class="token punctuation">,</span> Parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
　　<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
　　<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
　　<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
　　　　c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
　　　　<span class="token punctuation">}</span>
　　c<span class="token punctuation">.</span>uber <span class="token operator">=</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用</span>
　　<span class="token function">extend2</span><span class="token punctuation">(</span>Cat<span class="token punctuation">,</span> Animal<span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;大毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黄色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 动物</span>
</code></pre></div><h2 id="_3-15-5-非构造函数的继承方法"><a href="#_3-15-5-非构造函数的继承方法" class="header-anchor">#</a> 3.15.5 非构造函数的继承方法</h2> <p>构造函数继承的三种方法</p> <p>比如，现在有一个对象，叫做&quot;中国人&quot;。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Chinese <span class="token operator">=</span> <span class="token punctuation">{</span>
　　nation<span class="token operator">:</span><span class="token string">'中国'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 还有一个对象，叫做&quot;医生&quot;。</span>
<span class="token keyword">var</span> Doctor <span class="token operator">=</span><span class="token punctuation">{</span>
　　career<span class="token operator">:</span><span class="token string">'医生'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>请问怎样才能让&quot;医生&quot;去继承&quot;中国人&quot;，也就是说，我怎样才能生成一个&quot;中国医生&quot;的对象？
这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现&quot;继承&quot;。</p> <h3 id="_1、object-方法"><a href="#_1、object-方法" class="header-anchor">#</a> 1、<code>object()</code>方法</h3> <p>json格式的发明人Douglas Crockford，提出了一个<code>object()</code>函数，可以做到这一点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
　　<span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
　　<span class="token constant">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
　　<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>object()</code>函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 使用的时候，第一步先在父对象的基础上，生成子对象：</span>
　　<span class="token keyword">var</span> Doctor <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>Chinese<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 然后，再加上子对象本身的属性：</span>
　　Doctor<span class="token punctuation">.</span>career <span class="token operator">=</span> <span class="token string">'医生'</span><span class="token punctuation">;</span>
<span class="token comment">// 这时，子对象已经继承了父对象的属性了。</span>
　　<span class="token function">alert</span><span class="token punctuation">(</span>Doctor<span class="token punctuation">.</span>nation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//中国</span>
</code></pre></div><h3 id="_2、浅拷贝"><a href="#_2、浅拷贝" class="header-anchor">#</a> 2、浅拷贝</h3> <p>除了使用原型链(prototype)以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。</p> <p>下面这个函数，就是在做拷贝：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">extendCopy</span><span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
　　<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
　　<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
　　　　c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
　　<span class="token punctuation">}</span>
　　c<span class="token punctuation">.</span>uber <span class="token operator">=</span> p<span class="token punctuation">;</span>
　　<span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用</span>
<span class="token keyword">var</span> Doctor <span class="token operator">=</span> <span class="token function">extendCopy</span><span class="token punctuation">(</span>Chinese<span class="token punctuation">)</span><span class="token punctuation">;</span>
Doctor<span class="token punctuation">.</span>career <span class="token operator">=</span> <span class="token string">'医生'</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>Doctor<span class="token punctuation">.</span>nation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 中国</span>
</code></pre></div><p>这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址&quot;浅拷贝&quot;，而不是真正拷贝，因此存在父对象被篡改的可能。</p> <h3 id="_3、深拷贝"><a href="#_3、深拷贝" class="header-anchor">#</a> 3、深拷贝</h3> <p>所谓&quot;深拷贝&quot;，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用&quot;浅拷贝&quot;就行了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token parameter">p<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
　　<span class="token keyword">var</span> c <span class="token operator">=</span> c <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
　　<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
　　　　<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
　　　　　　c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
　　　　　　<span class="token function">deepCopy</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　　　<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
　　　　　　　c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
　　　　<span class="token punctuation">}</span>
　　<span class="token punctuation">}</span>
　　<span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用的时候这样写：</span>
<span class="token keyword">var</span> Doctor <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>Chinese<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：</span>
Chinese<span class="token punctuation">.</span>birthPlaces <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'北京'</span><span class="token punctuation">,</span><span class="token string">'上海'</span><span class="token punctuation">,</span><span class="token string">'香港'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
Doctor<span class="token punctuation">.</span>birthPlaces<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'厦门'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 这时，父对象就不会受到影响了。</span>
<span class="token function">alert</span><span class="token punctuation">(</span>Doctor<span class="token punctuation">.</span>birthPlaces<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//北京, 上海, 香港, 厦门</span>
<span class="token function">alert</span><span class="token punctuation">(</span>Chinese<span class="token punctuation">.</span>birthPlaces<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//北京, 上海, 香港</span>
</code></pre></div><p>目前，jQuery库使用的就是这种继承方法。</p> <p>参考:<a href="https://zhuanlan.zhihu.com/p/75265007" target="_blank" rel="noopener noreferrer">2分钟让你明白什么是面向对象编程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、
<a href="https://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="noopener noreferrer">Javascript 面向对象编程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/jaqi.note/frontend/javascript/sync&amp;asyn/" class="prev">
        3.14 同步与异步
      </a></span> <span class="next"><a href="/jaqi.note/frontend/javascript/ECMAScript/">
        3.16 ECMAScript
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/jaqi.note/assets/js/app.a8f46c6d.js" defer></script><script src="/jaqi.note/assets/js/2.244728d6.js" defer></script><script src="/jaqi.note/assets/js/46.47b4f55a.js" defer></script>
  </body>
</html>
